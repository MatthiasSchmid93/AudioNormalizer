import warnings

warnings.filterwarnings("ignore", category=RuntimeWarning)
import numpy as np
from pydub import AudioSegment
from alive_progress import alive_bar
from scipy.io.wavfile import write

class var:
    SAMPLERATE = 44100
    # List for found peaks
    peaks= []
    peak_areas = [[], [], [], []]
    # List where peaks are located in wav array by index
    peak_lst_index = []
    # List for peaks with start and end index (left signal)
    look_lst_left = []
    # List for peaks with start and end index (right signal)
    look_lst_right = []
    # Variable for iterating
    jump = 0

    # Get audio signal as 2D numpy array
    audio = np.array(
    AudioSegment.from_wav("test.wav").get_array_of_samples(), dtype=np.int16
    ).reshape(-1, 2)

    duration = len(audio) / 44100 / 60
    peak_limit = 10 * 1.6 * (60 * duration)
    volume = 32767

    # Replace all -1s and 1s with zero to avoid backround noise
    audio[audio == 1] = 0
    audio[audio == -1] = 0

    # Split original signal 
    audio_left_org, audio_right_org = np.split(audio, 2, axis=1)

    left_positive = np.array(audio_left_org, dtype=np.int16)
    left_negative = np.array(audio_left_org, dtype=np.int16)

    right_positive = np.array(audio_right_org, dtype=np.int16)
    right_negative = np.array(audio_right_org, dtype=np.int16)

    left_positive[left_positive < 0] = 1
    left_negative[left_negative >= 0] = -1

    right_positive[right_positive < 0] = 1
    right_negative[right_negative >= 0] = -1

    splited_signal = [left_positive, abs(left_negative), right_positive, abs(right_negative)]
    splited_signal_copy = [np.array(left_positive, dtype=np.int16), np.array(abs(left_negative), dtype=np.int16), np.array(right_positive, dtype=np.int16), np.array(abs(right_negative), dtype=np.int16)]

with alive_bar(len(var.splited_signal)) as bar:
    for i, signal in enumerate(var.splited_signal):
        np.extract(signal > var.volume, signal)
        while True:
            found_peaks = np.extract(signal >= var.volume, signal).size
            var.volume -= 250
            if found_peaks > var.peak_limit:
                var.peaks.append(np.where(signal >= var.volume)[0])
                var.volume = 32767
                break
        bar()

for x in range(4):
    i = 0
    count = 0
    while True:
        if i == len(var.peaks[x]) - 1:
            var.peak_areas[x].append([var.peaks[x][i] - count, var.peaks[x][i] + 1])
            break
        if var.peaks[x][i + 1] - var.peaks[x][i] == 1:
            count += 1
        if var.peaks[x][i + 1] - var.peaks[x][i] > 1:
            var.peak_areas[x].append([var.peaks[x][i] - count, var.peaks[x][i] + 1])
            count = 0
        i += 1
    for i, y in enumerate(var.peak_areas[x]):
        if y[0] >= y[1]:
            var.peak_areas[x][i][1] = y[1] + 1
            
def find_transient(i, x):
    _i = 0
    while True:
        if var.splited_signal[x][var.peak_areas[x][i][0] - _i] < 2:
            start = var.peak_areas[x][i][0] - _i
            _i = 0
            break
        _i += 1
    while True:
        if var.splited_signal[x][var.peak_areas[x][i][1] + _i] < 2:
            end = var.peak_areas[x][i][1] + _i
            break
        _i += 1
        
    return np.array(var.splited_signal[x][start : end], dtype=np.int32), end
    
                          
          
for x in range(4):
    del var.peak_areas[x][0]

for x in range(4):
    # List for numpy arrays
    lst = []
    # Replace all areas with zero where peaks are sitting and then find new max value to normalise to
    for i in range(len(var.peak_areas[x])):
        var.splited_signal_copy[x][
            var.peak_areas[x][i][0] : var.peak_areas[x][i][1]] = 0     
    global_peak = 32766 / var.splited_signal_copy[x].max()
    del_var = int((1 * global_peak))
    with alive_bar(len(var.peak_areas[x])) as bar:
        
        for i in range(len(var.peak_areas[x])):
            local_peak = (var.splited_signal[x][var.peak_areas[x][i][0] - 1] * global_peak) / var.splited_signal[x][var.peak_areas[x][i][0]]
            peak_area_values = np.array(var.splited_signal[x][var.peak_areas[x][i][0] : var.peak_areas[x][i][1]], dtype=np.int32)
            normalised_peak_area = peak_area_values * local_peak
            # Append peak window without normalising
            if normalised_peak_area.max() > 32767:
                transient_area, end = find_transient(i, x)
                lst.append(np.array(transient_area, dtype=np.int32))
                if i != len(var.peak_areas[x]) - 1:
                    lst.append(np.array(var.splited_signal[x][end : var.peak_areas[x][i + 1][0]] * global_peak, dtype=np.int32,))
            else:
                lst.append(np.array(peak_area_values * local_peak, dtype=np.int32))
                if i != len(var.peak_areas[x]) - 1:
                    # Append normalised arrays with no peak 
                    lst.append(np.array(var.splited_signal[x][var.peak_areas[x][i][1] : var.peak_areas[x][i + 1][0]] * global_peak, dtype=np.int32,))
            bar()
    # Insert normalised block until first peak
    lst.insert(0,np.array(var.splited_signal[x][0 : var.peak_areas[x][0][0]] * global_peak,dtype=np.int32,),)
    # Insert normalised block from last peak until end
    lst.insert(len(lst),np.array(var.splited_signal[x][var.peak_areas[x][len(var.peak_areas[x]) - 1][1] : len(var.splited_signal[x])] * global_peak, dtype=np.int32,),)
    # Transform all numpy arrays to one numpy array

    var.splited_signal[x] = np.concatenate((lst), axis=0, dtype=np.int32)

for i in range(4):
    var.splited_signal[i][var.splited_signal[i] > 32767] = 32767
    
var.splited_signal[1] = np.negative(var.splited_signal[1])
var.splited_signal[3] = np.negative(var.splited_signal[3])
  
audio_left = np.array([var.splited_signal[0], var.splited_signal[1]], dtype=np.int32).transpose().flatten()
audio_right = np.array([var.splited_signal[2], var.splited_signal[3]], dtype=np.int32).transpose().flatten()

audio_left = np.delete(audio_left, np.where(audio_left == -abs(del_var)))    
audio_right = np.delete(audio_right, np.where(audio_right == -abs(del_var)))
audio_left = np.delete(audio_left, np.where(audio_left == del_var))    
audio_right = np.delete(audio_right, np.where(audio_right == del_var))

audio_left[audio_left > 32766] = 32766
audio_right[audio_right > 32766] = 32766

audio_left = np.array(audio_left, dtype=np.int16)
audio_right = np.array(audio_right, dtype=np.int16)
  
write("new.wav", 44100, np.column_stack((audio_left, audio_right)))
