import warnings

warnings.filterwarnings("ignore", category=RuntimeWarning)
import numpy as np
from pydub import AudioSegment
from alive_progress import alive_bar
from scipy.io.wavfile import write


class var:
    FILE = "test.wav"
    SAMPLERATE = 44100

    # List for peaks with start and end index (left signal)
    peak_windows_left = []

    # List for peaks with start and end index (right signal)
    peak_windows_right = []

    # Variable for iterating
    jump = 0

    # Get audio signal as 2D numpy array
    wav = np.array(
        AudioSegment.from_wav(FILE).get_array_of_samples(), dtype=np.int16
    ).reshape(-1, 2)

    # Replace all -1s and 1s with zero to avoid backround noise
    wav[wav == 1] = 0
    wav[wav == -1] = 0

    # Split signal to left and right and convert all negative values to positive
    wav_left, wav_right = [abs(k) for k in np.split(wav, 2, axis=1)]

    # Split original signal
    wav_left_org, wav_right_org = np.split(wav, 2, axis=1)

    # Pack original arrays in list
    stereo_org = [wav_left_org, wav_right_org]

    # Pack postitive signal arrays in list
    stereo = [wav_left, wav_right]

    # Copy of original array for manipulation
    wav_deleted_peaks = np.column_stack((wav_left, wav_right))


def find_peaks():
    # Excecute two times for left and right signal
    for x in range(2):
        # List for found peaks
        peak_lst = []
        # List where peaks are located in original array by index
        peak_lst_index = []
        # Find peaks
        while True:
            if var.jump > len(var.stereo[x]):
                var.jump = 0
                break
            else:
                # Split array in block of 44100 samples = 1 sec
                block = var.stereo[x][var.jump : var.jump + 3000]
                # Find index of peak in block
                max = np.where(block == block.max())[0][0] + var.jump
                # Append index of peak to index list
                peak_lst_index.append(max)
                # Append value of peak to peak list
                peak_lst.append(block.max())
                # Jump to next block
                var.jump += 3000

        # Calculate average of all found peaks
        average = int((sum(peak_lst)) / len(peak_lst) * 1.1)

        # Delete all peaks that are under average peak
        for i, y in enumerate(peak_lst):
            if y < average:
                # Replace peak under average with value of 40.000
                peak_lst[i] = 40000
                peak_lst_index[i] = 40000

        # Delete all values with 40.000
        peak_lst = list(filter(lambda num: num != 40000, peak_lst))
        peak_lst_index = list(filter(lambda num: num != 40000, peak_lst_index))

        with alive_bar(len(peak_lst_index)) as bar:
            # Find window in where the peak sits
            for i, y in enumerate(peak_lst_index):
                # Iterate back until audio singal rises again
                while True:
                    if var.stereo[x][y] < var.stereo[x][y - 1]:
                        # Set start index
                        look_back = y
                        # set y to previous value
                        y = peak_lst_index[i]
                        break
                    y -= 1
                # Iterate forward until audio singal rises again
                while True:
                    if var.stereo[x][y] < var.stereo[x][y + 1]:
                        # Set end index
                        look_forward = y
                        break
                    y += 1
                # Append list with list of start and end index from peak
                if x == 0:
                    var.peak_windows_left.append([look_back, look_forward])
                if x == 1:
                    var.peak_windows_right.append([look_back, look_forward])
                bar()
    # Delete first peak if audio is starting silent
    if var.peak_windows_left[0][0] < 0 or var.peak_windows_left[0][1] < 0:
        del var.peak_windows_left[0]
    if var.peak_windows_right[0][0] < 0 or var.peak_windows_right[0][1] < 0:
        del var.peak_windows_right[0]

    peak_windows_left_right = [var.peak_windows_left, var.peak_windows_right]
    # Delete peaks that overlap
    for x in range(2):
        for i, y in enumerate(peak_windows_left_right[x]):
            try:
                while True:
                    if y[1] >= peak_windows_left_right[x][i + 1][0]:
                        del peak_windows_left_right[x][i + 1]
                    else:
                        break
            except:
                pass

    return peak_windows_left_right


def normalise(peak_windows_left_right):

    for x in range(2):
        # List for numpy arrays
        lst = []
        # Replace all areas with zero where peaks are sitting and then find new max value to normalise to
        for y in range(len(peak_windows_left_right[x])):
            var.stereo[x][
                peak_windows_left_right[x][y][0] : peak_windows_left_right[x][y][1]
            ] = 0
        global_peak = 32766 / var.stereo[x].max()
        with alive_bar(len(peak_windows_left_right[x])) as bar:
            for i in range(len(peak_windows_left_right[x])):
                # Append peak window without normalising
                lst.append(
                    var.stereo_org[x][
                        peak_windows_left_right[x][i][0] : peak_windows_left_right[x][
                            i
                        ][1]
                    ]
                )
                try:
                    # Append normalised arrays with no peak (* global_peak is where the magic happens)
                    lst.append(
                        np.array(
                            var.stereo_org[x][
                                peak_windows_left_right[x][i][
                                    1
                                ] : peak_windows_left_right[x][i + 1][0]
                            ]
                            * global_peak,
                            dtype=np.int16,
                        )
                    )
                except:
                    pass
                bar()
        # Insert normalised block until first peak
        lst.insert(
            0,
            np.array(
                var.stereo_org[x][0 : peak_windows_left_right[x][0][0]] * global_peak,
                dtype=np.int16,
            ),
        )
        # Insert normalised block from last peak until end
        lst.insert(
            len(lst),
            np.array(
                var.stereo_org[x][
                    peak_windows_left_right[x][len(peak_windows_left_right[x]) - 1][
                        1
                    ] : len(var.stereo_org[x])
                ]
                * global_peak,
                dtype=np.int16,
            ),
        )
        # Transform all numpy arrays to one numpy array
        if x == 0:
            wav_normalised_left = np.concatenate((lst), axis=0, dtype=np.int16)
        if x == 1:
            wav_normalised_right = np.concatenate((lst), axis=0, dtype=np.int16)

        # Transform left and right signal array to one 2D array
    return np.column_stack((wav_normalised_left, wav_normalised_right))


def main():
    write(var.FILE, var.SAMPLERATE, normalise(find_peaks()))


if __name__ == "__main__":
    main()
